---
// src/pages/team/[...slug].astro
import { getEntry, getCollection, render, type CollectionEntry } from 'astro:content';
import TeamLayout from '../../layouts/TeamLayout.astro';
import { siteDefaults } from '../../config/siteDefaults';
import LoadMorePosts from '../../components/LoadMorePosts.astro';
import Card from '../../components/ui/Card.astro';
import type { CardProps } from '../../types/CardProps';

// ---------------------
// 1) Params + guard
// ---------------------
const { slug } = Astro.params;
const slugId = Array.isArray(slug) ? slug.join('/') : slug;

if (!slugId || slugId === '_team-member' || slugId === '_team' || slugId.startsWith('_')) {
  throw Astro.redirect('/404/');
}

// Team entry
const post = await getEntry('team', slugId);
if (!post) throw Astro.redirect('/404/');

const { Content } = await render(post);

// ---------------------
// 2) Authorable collections
// ---------------------
const AUTHORABLE_KEYS = ['blog', 'service', 'resource', 'post'] as const;
type AuthorableKey = typeof AUTHORABLE_KEYS[number];

type CollectionsMap = typeof siteDefaults.collections;
type CfgFor<K extends keyof CollectionsMap> = CollectionsMap[K];

function baseFor(key: AuthorableKey): string {
  const cfg = siteDefaults.collections[key] as CfgFor<AuthorableKey>;
  const base = (cfg?.base ?? String(key)).replace(/^\/|\/$/g, '');
  return base ? `${base}/` : '';
}

// Works for string refs or { id } refs
function authorMatches(authors: unknown, wantedId?: string): boolean {
  if (!wantedId) return false;
  const arr: any[] = Array.isArray(authors) ? authors : [];
  return arr.some((a) => (typeof a === 'string' ? a === wantedId : a?.id === wantedId));
}

// Normalize last-modified (fallbacks)
function getLastModified(e: CollectionEntry<AuthorableKey>): string {
  // prefer lastModified → updatedDate → publishedDate
  return (e.data as any).lastModified || (e.data as any).updatedDate || e.data.publishedDate;
}

// Hidden filter: draft OR any path segment starting with "_"
function isHiddenEntry(e: CollectionEntry<AuthorableKey>): boolean {
  if (e.data?.draft === true) return true;

  const idHasHidden = e.id.split('/').some((seg) => seg.startsWith('_'));

  // prefer `entry.slug` (Astro-provided), else frontmatter slug, else ""

  const rawSlug: string = (e as any).slug ?? (e.data as any)?.slug ?? '';
  const slugHasHidden = String(rawSlug)
    .split('/')
    .some((seg) => seg.startsWith('_'));

  return idHasHidden || slugHasHidden;
}

// ---------------------
// 3) Collect authored posts
// ---------------------
type AuthoredPost = {
  title: string;
  description: string;
  slug: string;
  collection: AuthorableKey;
  collectionBase: string;
  heroImage?: string | null;
  heroImageAlt?: string;
  lastModified?: string;
};

const authoredPosts: AuthoredPost[] = [];

async function collectFrom(key: AuthorableKey) {
  const entries = await getCollection(key);
  const collectionBase = baseFor(key);

  for (const entry of entries) {
    if (isHiddenEntry(entry)) continue;
    if (!authorMatches((entry.data as any)?.authors, slugId)) continue;


    const entrySlug: string = (entry as any).slug ?? entry.data.slug;

    authoredPosts.push({
      title: entry.data.title,
      description: entry.data.description,
      slug: entrySlug,
      collection: key,
      collectionBase,
      heroImage: (entry.data as any).heroImage ?? null,
      heroImageAlt: (entry.data as any).heroImageAlt ?? entry.data.title,
      lastModified: getLastModified(entry),
    });
  }
}

for (const key of AUTHORABLE_KEYS) {
  await collectFrom(key);
}

// Sort newest → oldest by lastModified (string dates are ISO in content)
authoredPosts.sort((a, b) => {
  const da = a.lastModified ? new Date(a.lastModified).getTime() : 0;
  const db = b.lastModified ? new Date(b.lastModified).getTime() : 0;
  return db - da;
});

// ---------------------
// 4) Slice for initial view
// ---------------------
const postDisplay = 6;
const initialPosts = authoredPosts.slice(0, postDisplay);
const hasMore = authoredPosts.length > postDisplay;

// ---------------------
// 5) Team props
// ---------------------
const {
  name,
  prefix = '',
  role,
  highestDegree = '',
  shortBio = '',
  experience,
  expertise = [],
  awards = [],
  affiliation = '',
  addressing = '',
  email,
  website = '',
  color = 'hsl(220, 60%, 70%)',
  joined = '',
  left = '',
  useGravatar = false,
  gravatarEmail = '',
  useImage = false,
  useInitial = false,
  initialText = '',
  image = '',
  imageAlt = '',
  profileImage = '',
  profileImageAlt = '',
  profileImageCaption = '',
  profileImageTitle = '',
  social = {} as Record<string, string>,
  featured = false,
} = post.data;

const teamProps = {
  name,
  prefix,
  role,
  highestDegree,
  shortBio,
  experience,
  expertise,
  awards,
  affiliation,
  addressing,
  email,
  website,
  color,
  joined,
  left,
  useGravatar,
  gravatarEmail,
  useImage,
  useInitial,
  initialText,
  photo: image,
  imageAlt,
  profileImage,
  profileImageAlt,
  profileImageCaption,
  profileImageTitle,
  social,
  featured,
  slug: post.data.slug ?? slugId,
  id: slugId,
};

// ---------------------
// 6) Cards
// ---------------------
const authorCards: CardProps[] = initialPosts.map((p) => ({
  link: `/${p.collectionBase}${p.slug}/`,
  linkAriaLabel: `Read post: ${p.title}`,
  image: p.heroImage || undefined,
  afterImage: p.collection,
  imageAlt: p.heroImageAlt || p.title,
  title: p.title,
  description: p.description,
  date: p.lastModified ? new Date(p.lastModified).toLocaleDateString() : undefined,
  orientation: 'vertical',
  imageSize: 320,
  roleType: 'article',
  loading: 'lazy',
  className: 'w-100p mn-w-320',
  imageClassName: '',
  otherEntries: [],
}));
---

  <TeamLayout {...teamProps}>
    <Content />
    <Fragment slot="posts">
      {authorCards.length > 0 && (
        <section id="author-posts-section" class="max-w-site w-100p mx-auto my-1 py-1">
          <h2 class="text-xl bold">Posts by {name}</h2>

          <div id="author-posts" class="flex max-w-site w-100p wrap gap my-1 ai-f-start jc-center">
            {authorCards.map((card) => (
              <Card {...card} />
            ))}
          </div>

          {hasMore && (
            <LoadMorePosts
              slug={slugId}
              loaded={initialPosts.length}
              total={authoredPosts.length}
              sort="lastmodified"
              collections={AUTHORABLE_KEYS as unknown as string[]}
            />
          )}
        </section>
      )}
    </Fragment>
  </TeamLayout>
