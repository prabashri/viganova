---
import BaseLayout from '@/layouts/BaseLayout.astro';
import PaginationSeo from '@/components/PaginationSeo.astro';
import PaginationRedirect from '@/components/PaginationRedirect.astro';
import Pagination from '@/components/Pagination.astro';
import CardCollections from '@/components/ui/CardCollections.astro';
import HeroCollections from '@/components/ui/HeroCollections.astro';

import { getCollection } from 'astro:content';
import { siteDefaults } from '@/config/siteDefaults';
import { siteImages } from '@/config/siteImages';
import { paginate } from '@/utils/paginate';
import type { HeadProps } from '@/types/HeadProps';

import modifiedDatesJson from '@/data/modified-dates.json';
import { getCollectionUrl } from '@/utils/getCollectionUrl';
import { mapEntryToCard } from '@/utils/mapEntryToCard';
import type { CardProps } from '@/types/CardProps';

// ðŸ”„ ðŸ”„ ðŸ”„ CHANGEABLE VARIABLES ðŸ”„ ðŸ”„ ðŸ”„
const entryType = "tags"; // "tags" or "categories"
const currentEntryParam = Astro.params.tag?.toLowerCase() ?? 'unknown';
import { tagMeta as entryMeta } from '@/config/tagMeta'; 
const fieldName = 'tags';
const metaMap = new Map<string, { name: string; title?: string; description?: string; image?: string; url?: string }>(
  Object.entries(entryMeta).map(([name, meta]) => [name.toLowerCase(), { name, ...meta }])
);
// ðŸ”„ ðŸ”„ ðŸ”„ END CHANGEABLE VARIABLES ðŸ”„ ðŸ”„ ðŸ”„

// Constants
const POSTS_PER_PAGE = siteDefaults.postsPerCollectionsPage ?? 10;
const currentPage = Number(Astro.params.page ?? '1');

function hasEntry(post: any, entryValue: string): boolean {
  return Array.isArray(post.data?.[fieldName]) &&
    post.data[fieldName].some((v: string) => typeof v === 'string' && v.toLowerCase() === entryValue.toLowerCase());
}

function getModifiedDateKey(entry: any) {
  const key = `${entry.collection}/${entry.slug ?? entry.id}`;
  return (modifiedDatesJson as Record<string, string>)[key]
    ?? entry.data.lastModified
    ?? entry.data.publishedDate
    ?? entry.data.date;
}

// Collect matching posts
const collectionsWithField = Object.entries(siteDefaults.collections)
  .filter(([_, config]) => config?.tags === true) // works for categories too
  .map(([key]) => key as keyof typeof siteDefaults.collections);

let matchedEntries: any[] = [];
for (const coll of collectionsWithField) {
  const posts = await getCollection(coll);
  matchedEntries.push(
    ...posts.filter((entry: any) => {
      const slug = typeof entry.slug === 'string' ? entry.slug : '';
      return (
        hasEntry(entry, currentEntryParam) &&
        !slug.startsWith('_') &&
        entry.data?.draft !== true
      );
    })
  );
}

// Sort by modified date
matchedEntries.sort((a, b) => new Date(getModifiedDateKey(b)).getTime() - new Date(getModifiedDateKey(a)).getTime());

// Pagination
const { pageItems: paginatedEntries, totalPages } = paginate(matchedEntries, currentPage, POSTS_PER_PAGE);

// Meta
const isKnownEntry = metaMap.has(currentEntryParam);
const meta = metaMap.get(currentEntryParam) ?? {
  name: currentEntryParam,
  title: currentEntryParam.charAt(0).toUpperCase() + currentEntryParam.slice(1),
  description: `Explore posts in "${currentEntryParam}" on ${siteDefaults.siteName}.`,
  image: `/${siteDefaults.fieldCollections[entryType].defaultImage}`,
  url: `/${entryType}/${currentEntryParam}/`
};

const baseUrl = `/${entryType}/${currentEntryParam}`;

// SEO
const pageSeo: HeadProps = {
  title: `${meta.title} | ${siteDefaults.siteName}`,
  description: meta.description,
  image: meta.image || siteImages.image,
  breadcrumbs: [
    { name: 'Home', url: '/' },
    { name: siteDefaults.fieldCollections[entryType].title, url: `/${entryType}/` },
    { name: meta.title ?? currentEntryParam, url: `${baseUrl}/` }
  ],
  listItems: paginatedEntries.map(p => ({
    name: "title" in p.data ? p.data.title : 'Untitled',
    url: getCollectionUrl(p.collection, "slug" in p.data && typeof p.data.slug === "string" ? p.data.slug : String(p.id))
  })),
  type: 'collection',
  index: paginatedEntries.length > 0,
  authors: []
};

const postCards: CardProps[] = paginatedEntries.map((entry, idx) =>
  mapEntryToCard(entry, idx, { currentEntryParam, entryType, fieldName, metaMap })
);
---

<BaseLayout headProps={pageSeo}>
  <PaginationRedirect basePath={baseUrl} currentPage={currentPage} />
  <PaginationSeo basePath={baseUrl} currentPage={currentPage} totalPages={totalPages} />

   <HeroCollections
    title={meta.title ?? currentEntryParam}
    description={meta.description}
    bgColorClass="bg-secondary-base"
    textColorClass="col-base-00"
  />

  <section class="max-w-site mx-auto my-2 py-2">
    {paginatedEntries.length === 0 ? (
      <p class="ta-center mt-2">No posts found for this {entryType.slice(0, -1)}.</p>
    ) : (
      <CardCollections cards={postCards} wrapper="ul" roleType="list" entry={entryType} />
    )}
  </section>

  <Pagination currentPage={currentPage} totalPages={totalPages} basePath={baseUrl} />
</BaseLayout>
