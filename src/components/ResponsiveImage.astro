---
// src/components/ResponsiveImage.astro
import { registerPreloadImage } from '@/utils/preloadRegistry';
import { registerSchemaImage } from '@/utils/registerSchemaImage';
import { siteDefaults } from '@/config/siteDefaults';
import { siteImages } from '@/config/siteImages';

// ⬇️ use just these
import { toAbsoluteUrl, toRelativeUrl } from '@/utils/urls';

import type {
  ImageFormat,
  ImageVariant,
  ImageVariants,
  ImageBreakpoints,
  ImageMetaSlim
} from '@/types/imageProps';

import { getImageMeta, constructUrl } from '@/utils/getImage';

interface Props {
  src: string;
  imageMeta?: ImageMetaSlim | null;
  alt: string;
  title?: string;
  caption?: string;
  sizes?: number | string;
  id?: string;
  className?: string;
  imageClassName?: string;
  loading?: 'lazy' | 'eager' | 'delay';
  variant?: ImageVariant;
  width?: number | string;
  height?: number;
  addSchema?: boolean;
  breakpoints?: { mobile: number; desktop: number };
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';
}

const {
  src,
  imageMeta,
  alt,
  title,
  caption,
  id = '',
  className = '',
  imageClassName = 'inline-image',
  variant = 'auto',
  width,
  height,
  loading = 'lazy',
  objectFit = 'cover',
  addSchema = true,
} = Astro.props as Props;

const variants: ImageVariants = siteImages.variants;
const breakpoints: ImageBreakpoints = siteImages.breakpoints;

const nonce = (Astro.locals as any).nonce;

// meta (either from props or util)
const meta = imageMeta ?? getImageMeta(src);
const hasData = !!meta;

let defaultAspect = '';
let formats: string[] = [];
let aspectClass = '';
let objectFitClass = `object-${objectFit}`;
let srcSetList = '';
let sizesAttr = '';
let fallbackSrc = '';
let imageMaxUrl = '';
let preloadWidths: number[] = [];
let primaryFormat: ImageFormat = 'jpeg';

function pickLE(available: number[], target?: number): number | undefined {
  if (!target) return undefined;
  const asc = [...available].sort((a,b) => a-b);
  for (let i = asc.length - 1; i >= 0; i--) {
    if (asc[i] <= target) return asc[i];
  }
  return asc[0]; // if all are > target, use smallest to avoid upscaling in CSS
}

if (hasData && meta) {
  defaultAspect = meta.aspect;

  // format priority (webp > avif > png > jpeg/jpg)
  const formatPriority: Record<ImageFormat, number> = { webp: 1, avif: 2, png: 3, jpeg: 4, jpg: 4 };
  formats = [...meta.formats].sort(
    (a, b) => (formatPriority[a as ImageFormat] ?? 99) - (formatPriority[b as ImageFormat] ?? 99)
  );
  
  const availableWidths: number[] = meta.sizes.map(Number).sort((a, b) => a - b);

  const wMobile  = pickLE(availableWidths, variants.mobile)  ?? availableWidths[0];
  const wTablet  = variants.tablet ? pickLE(availableWidths, Number(variants.tablet)) : undefined;
  const wDesktop = pickLE(availableWidths, variants.desktop) ?? wTablet ?? wMobile;
  const wFull    = pickLE(availableWidths, variants.full)    ?? wDesktop;
  const wFeatured= pickLE(availableWidths, variants.featured)?? wFull;
  const wThumb   = pickLE(availableWidths, variants.thumbnail)?? availableWidths[0];

  primaryFormat = (formats[0] as ImageFormat) || 'jpeg';

  // Build a path with leading slash, then map via URL helpers
  const buildPath = (w: number, fmt: string) =>
    `/${meta.path.replace(/^\/?/, '')}-w${w}-a${defaultAspect}.${fmt}`;

  const buildRelOrCdn = (w: number, fmt: string) =>
    toRelativeUrl(buildPath(w, fmt)); // cdn:auto → CDN absolute if configured, else relative

  // --- Responsive sources (preserve your switch logic) ---
  switch (variant) {
    case 'thumbnail': {
      fallbackSrc = buildRelOrCdn(wThumb, primaryFormat);

      // Schema must use site-absolute (never CDN)
      imageMaxUrl = toAbsoluteUrl(buildPath(wFull, primaryFormat), { cdn: false });

      const bigW = (wTablet ?? wDesktop);
      srcSetList = `${buildRelOrCdn(wThumb, primaryFormat)} ${wThumb}w, ${buildRelOrCdn(bigW, primaryFormat)} ${bigW}w`;
      sizesAttr = `(max-width: ${breakpoints.mobileMax}px) ${wThumb}px, ${bigW}px`;
      preloadWidths = [wThumb];
      break;
    }

    case 'mobile':
    case 'desktop':
    case 'featured':
    case 'auto':
    default: {
      fallbackSrc = buildRelOrCdn(wMobile, primaryFormat);

      // Prefer constructUrl if provided → normalize to path → site-absolute for schema
      const constructed = (constructUrl(meta, 'full', primaryFormat) as string | undefined);
      const fullPath = constructed ? `/${constructed.replace(/^\/?/, '')}` : buildPath(wFull, primaryFormat);
      imageMaxUrl = toAbsoluteUrl(fullPath, { cdn: false });

      const seenWidths = new Set<number>();
      srcSetList = [wMobile, wTablet, wDesktop, wFull]
        .filter((w): w is number => {
          if (typeof w !== 'number' || seenWidths.has(w)) return false;
          seenWidths.add(w);
          return true;
        })
        .map((w) => `${buildRelOrCdn(w, primaryFormat)} ${w}w`)
        .join(', ');

      // Responsive sizes (unchanged)
      const sizesList: string[] = [];
      if (wMobile)  sizesList.push(`(max-width: ${breakpoints.mobileMax}px) ${wMobile}px`);
      if (wTablet)  sizesList.push(`(max-width: ${breakpoints.tabletMax}px) ${wTablet}px`);
      if (wDesktop) sizesList.push(`(max-width: ${breakpoints.fullMin - 1}px) ${wDesktop}px`);
      sizesList.push(`${wFull}vw`);
      sizesAttr = sizesList.join(', ');

      preloadWidths = [wMobile, wFull, wTablet ?? wDesktop];
      break;
    }
  }

  // Deduplicate preload widths
  const seen = new Set<number>();
  const finalPreloadWidths = preloadWidths.filter(w => !seen.has(w) && seen.add(w));

  // Preload logic (always includes mobile and full)
  if (loading === 'eager' ) {
    const priority = loading === 'eager' ? 'high' : 'low';
    for (const w of finalPreloadWidths) {
      let media: string | undefined;
      if (w === wMobile) {
        media = `(max-width: ${breakpoints.mobileMax}px)`;
      } else if (w === wFull) {
        media = `(min-width: ${breakpoints.fullMin}px)`;
      } else {
        const minW = breakpoints.mobileMax + 1;
        const maxW = breakpoints.fullMin - 1;
        media = `(min-width: ${minW}px) and (max-width: ${maxW}px)`;
      }
      // Preload using toRelativeUrl (CDN absolute if configured, else relative)
      registerPreloadImage({
        src: toRelativeUrl(buildPath(w, primaryFormat)),
        media,
        fetchPriority: priority
      });
    }
  }

  if (addSchema) {
    registerSchemaImage(imageMaxUrl); // site-absolute, SEO-safe
  }

  aspectClass = `a-${defaultAspect}`;
}
---
{!hasData ? (
  <div class={`flex ai-center jc-center bg-primary-lighter br ${aspectClass} ${loading === 'delay' ? 'opacity-02 transition-opacity duration-300' : ''} h-fit ${className}`}>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 225" class={`w-100p h-auto ${imageClassName} ${objectFitClass}`}>
      <rect width="400" height="225" fill="#00000000"></rect>
    </svg>
    <span class="absolute bold text-base">{siteDefaults.siteName}</span>
  </div>
) : (
  caption ? (
    <figure id={id} class={`block image-wrapper w-100p ${aspectClass} h-fit ${className}`}>
      <picture>
        {formats.map(fmt => (
          <source
            type={`image/${fmt === 'jpg' ? 'jpeg' : fmt}`}
            {...(loading === 'delay'
              ? { 'data-srcset': srcSetList.replaceAll(`.${primaryFormat}`, `.${fmt}`), 'delay-image': true }
              : { srcset: srcSetList.replaceAll(`.${primaryFormat}`, `.${fmt}`) })}
            sizes={sizesAttr}
          />
        ))}
        <img
          {...(loading === 'delay'
            ? { 'data-src': fallbackSrc, 'data-srcset': srcSetList, 'delay-image': true }
            : { src: fallbackSrc, srcset: srcSetList })}
          sizes={sizesAttr}
          width={width}
          height={height}
          alt={alt}
          title={title}
          loading={loading === 'delay' ? 'lazy' : loading}
          decoding="async"
          fetchpriority={loading === 'eager' ? 'high' : loading === 'delay' ? 'low' : undefined}
          class={`block w-100p h-auto br ${imageClassName} ${objectFitClass} ${loading === 'delay' ? 'opacity-0 transition-opacity duration-300' : ''}`}
        />
      </picture>
      <figcaption class="text-s">{caption}</figcaption>
    </figure>
  ) : (
    <figure id={id} class={`block image-wrapper w-100p ${aspectClass} h-fit ${className}`}>
      <picture>
        {formats.map(fmt => (
          <source
            type={`image/${fmt === 'jpg' ? 'jpeg' : fmt}`}
            {...(loading === 'delay'
              ? { 'data-srcset': srcSetList.replaceAll(`.${primaryFormat}`, `.${fmt}`), 'delay-image': true }
              : { srcset: srcSetList.replaceAll(`.${primaryFormat}`, `.${fmt}`) })}
            sizes={sizesAttr}
          />
        ))}
        <img
          {...(loading === 'delay'
            ? { 'data-src': fallbackSrc, 'data-srcset': srcSetList, 'delay-image': true }
            : { src: fallbackSrc, srcset: srcSetList })}
          sizes={sizesAttr}
          width={width}
          height={height}
          alt={alt}
          title={title}
          loading={loading === 'delay' ? 'lazy' : loading}
          decoding="async"
          fetchpriority={loading === 'eager' ? 'high' : loading === 'delay' ? 'low' : undefined}
          class={`block w-100p h-auto br ${imageClassName} ${objectFitClass} ${loading === 'delay' ? 'opacity-0 transition-opacity duration-300' : ''}`}
        />
      </picture>
    </figure>
  )
)}
{addSchema && hasData && (
  <script
    is:inline
    data-id="image-schema"
    type="application/ld+json" 
    nonce={nonce}
    set:html={JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'ImageObject',
      '@id': imageMaxUrl,      // site absolute
      contentUrl: imageMaxUrl, // site absolute
      url: imageMaxUrl,        // site absolute
      caption: caption || title || alt,
      description: alt,
      representativeOfPage: true,
      width: width ?? 640,
      height: height ?? Math.round((640 * Number((defaultAspect || '16x9').split('x')[1])) / Number((defaultAspect || '16x9').split('x')[0])),
    })}
  />
)}
