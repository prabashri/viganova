---
/* src/components/CssHead.astro */
import manifest from '@/data/assets-manifest.json';
import { inlineCss } from '@/data/generated-inline-css.ts';

const nonce = (Astro.locals as any).nonce;
const isDev = import.meta.env.DEV;

/** Dev order – your existing list */
const devCssOrder: string[] = [
  '/src/styles/inline/base.css',
  '/src/styles/inline/colors.css',
  '/src/styles/inline/header.css',
  '/src/styles/inline/size.css',
  '/src/styles/inline/hero.css',
  // main css
  '/src/styles/main/base.css',
  '/src/styles/main/components.css',
  '/src/styles/main/colors.css',
  '/src/styles/main/toc.css',
  '/src/styles/main/form.css',
  '/src/styles/main/utilities.css',
  '/src/styles/main/non-critical.css',
  '/src/styles/main/search-icon.css',
  '/src/styles/main/search.css',
  '/src/styles/main/footer.css',
  '/src/styles/main/faq.css',
  '/src/styles/main/markdown.css',
  '/src/styles/main/table.css',
  '/src/styles/main/blockquote.css',
  '/src/styles/main/consent-banner.css',
  // '/src/styles/main/print.css',
  '/src/styles/main/star-rating.css',
  '/src/styles/main/callout.css',
];

/** Helpers to safely read the manifest (shape-agnostic) */
function flattenValues(obj: any): string[] {
  const out: string[] = [];
  const visit = (v: any) => {
    if (!v) return;
    if (typeof v === 'string') {
      out.push(v);
    } else if (Array.isArray(v)) {
      v.forEach(visit);
    } else if (typeof v === 'object') {
      // prefer .file if present
      if (typeof v.file === 'string') out.push(v.file);
      // but also scan all props
      Object.values(v).forEach(visit);
    }
  };
  visit(obj);
  return out;
}

/** Try to find a “main” css first, then others */
let mainCss: string | undefined =
  (manifest as any)?.css?.main?.file ??
  (manifest as any)?.main?.css?.file ??
  (manifest as any)?.css?.main ??
  undefined;

// collect all css-like paths (endsWith .css)
const allCssCandidates = flattenValues((manifest as any)?.css ?? manifest)
  .filter((p) => typeof p === 'string' && p.endsWith('.css'));

// de-dupe while preserving order
const seen = new Set<string>();
const dedupe = (arr: string[]) => arr.filter((p) => !seen.has(p) && (seen.add(p), true));

let cssFiles: string[] = [];
if (!isDev) {
  const rest = allCssCandidates.filter((p) => p !== mainCss);
  cssFiles = dedupe([mainCss, ...rest].filter(Boolean) as string[]);
}

/** Choose a preload target (the first = main) */
const preloadCss = !isDev ? cssFiles[0] : undefined;
---

<!-- ✅ Preload fonts early -->
<link rel="preload" href="/fonts/Inter-Regular-Subset.woff2" as="font" fetchpriority="high" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/Inter-Bold-Subset.woff2" as="font" fetchpriority="high" type="font/woff2" crossorigin>

<!-- ✅ PROD: Preload main CSS (if found) -->
{!isDev && preloadCss && (
  <link rel="preload" as="style" href={preloadCss} fetchpriority="high" />
)}

<!-- ✅ PROD: Inline critical CSS (CSP nonce) -->
{!isDev && inlineCss && (
  <style nonce={nonce} id="inline-css" set:html={inlineCss} />
)}

<!-- ✅ PROD: Load all discovered CSS files (main first) -->
{!isDev && cssFiles.map((href) => (
  <link rel="stylesheet" href={href} fetchpriority={href === preloadCss ? 'high' : undefined} />
))}

<!-- ✅ DEV: Load your authored list (cache-bust via timestamp) -->
{isDev && devCssOrder.map((href) => (
  <link rel="stylesheet" href={`${href}?t=${import.meta.hot?.data?.timestamp ?? Date.now()}`} />
))}
