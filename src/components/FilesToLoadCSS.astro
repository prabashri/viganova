---
// src/components/FilesToLoadCSS.astro

/**
 * CSS loader (per-page inline or link), manifest-aware.
 *
 * Item props:
 *  - name | href  (one required)
 *  - inline?: boolean                 // default false (true => inline <style> from generated module)
 *  - fetchPriority?: 'high'|'auto'|'low'  // default 'high' (ignored when inline:true)
 *  - id?: string
 *  - media?: string                   // ONLY for <link>, not inline
 *
 * Inline order of preference:
 *   1) Generated module recorded at manifest.css["pages:<name>"].inlineModule
 *   2) Dev/source raw: /src/styles/pages/<name>.css via import.meta.glob
 *   3) Fallback to <link>
 * 
 * usage examples:
 * <FilesToLoadCSS
  files={[
    { name: 'home', inline: true, id: 'critical-home' }, // inlines the string from inlineModule if present
    { name: 'home' }, 
      { href: 'https://cdn.example.com/ui/tooltip.css' },
    { href: '/assets/vendor/photoswipe.css', id: 'photoswipe' },
     { name: 'checkout' },                    // will emit <link rel="preload" as="style" ...> in prod
      { name: 'gallery', fetchPriority: 'low' },     // outputs <link data-href="..." data-css-noncritical="1">
  ]}
/>

 */

import manifest from "@/data/assets-manifest.json";

type FetchPriority = 'high' | 'auto' | 'low';
type BaseItem = { id?: string; media?: string; inline?: boolean; fetchPriority?: FetchPriority; };
type NamedItem = BaseItem & { name: string; href?: never };
type HrefItem  = BaseItem & { href: string;  name?: never };
interface Props { files: Array<NamedItem|HrefItem>; dedupe?: boolean; }

const { files, dedupe = true } = Astro.props as Props;

const isDev = import.meta.env.DEV;
const bust = (import.meta as any)?.hot?.data?.timestamp ?? Date.now();

const nonce = (Astro.locals as any).nonce;

// Source raw (dev helper)
const rawByPath = import.meta.glob('/src/styles/pages/*.css', {
  query: '?raw',
  import: 'default',
  eager: true,
}) as Record<string,string>;

/** Resolve manifest page entry & helpers */
function manifestEntry(name: string) {
  return (manifest as any)?.css?.[`pages:${name}`] ?? null;
}
function resolveHrefForName(name: string): string | null {
  if (!name) return null;
  if (isDev) return `/src/styles/pages/${name}.css?t=${bust}`;
  return manifestEntry(name)?.file ?? null;
}
function resolveInlineModulePath(name: string): string | null {
  return manifestEntry(name)?.inlineModule ?? null; // e.g. '/src/data/page-css/home.ts'
}
function resolveRawSource(name: string): string | null {
  const key = `/src/styles/pages/${name}.css`;
  return rawByPath[key] ? key : null;
}

/** Dedupe */
type Key = string;
const cssOnce: Set<Key> = (Astro.locals as any).__cssOnce ??= new Set<Key>();
const keyForInline = (name?: string, id?: string) => `inline|${name ?? ''}|${id ?? ''}`;
const keyForFile   = (href: string, media: string|undefined, mode: FetchPriority) =>
  `file|${href}|${media ?? ''}|${mode}`;
---

{files.map((item) => {
  const fp = (item.fetchPriority ?? 'high') as FetchPriority;

  // 1) compute link href (for non-inline or fallback)
  const linkHref = 'name' in item ? resolveHrefForName(item.name ?? '') : (item.href || null);

  // 2) INLINE branch
  if (item.inline) {
    let cssString: string | null = null;

    if ('name' in item && item.name) {
      // a) try generated module first
      const modPath = resolveInlineModulePath(item.name);
      if (modPath) {
        // import all generated modules and pick by filename
        const mods = import.meta.glob('/src/data/page-css/*.ts', { eager: true });
        const mod = mods[modPath] as any;
        if (mod && typeof mod.default === 'string') {
          cssString = mod.default;
        }
      }

      // b) dev/source raw fallback
      if (!cssString && isDev) {
        const srcKey = resolveRawSource(item.name);
        if (srcKey) cssString = rawByPath[srcKey] ?? null;
      }
    }

    if (cssString) {
      const k = keyForInline('name' in item ? item.name : undefined, item.id);
      if (dedupe && cssOnce.has(k)) return null;
      cssOnce.add(k);
      return <style is:inline nonce={nonce} id={item.id} set:html={cssString} />;
    }

    // c) final fallback â†’ link
    if (!linkHref) return null;
    const k = keyForFile(linkHref, item.media, 'auto');
    if (dedupe && cssOnce.has(k)) return null;
    cssOnce.add(k);
    return <link id={item.id} rel="stylesheet" href={linkHref} {...(item.media ? { media: item.media } : {})} />;
  }

  // 3) non-inline link modes
  if (!linkHref) return null;
  const k = keyForFile(linkHref, item.media, fp);
  if (dedupe && cssOnce.has(k)) return null;
  cssOnce.add(k);

  return (
    <>
      {!isDev && fp === 'high' && (
        <link rel="preload" as="style" href={linkHref} fetchpriority="high" {...(item.media ? { media: item.media } : {})} />
      )}
      {fp === 'low' ? (
        <link id={item.id} rel="stylesheet" data-href={linkHref} data-css-noncritical="1" {...(item.media ? { media: item.media } : {})} />
      ) : (
        <link id={item.id} rel="stylesheet" href={linkHref} {...(item.media ? { media: item.media } : {})} />
      )}
    </>
  );
})}
