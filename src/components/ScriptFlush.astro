---
// src/components/ScriptFlush.astro
/* Emits scripts for the given position (head|footer).
   - Merges: (registered scripts) + (global scripts)
   - Resolves globals via assets-manifest.json (prod hashed / dev original)
   - Auto-ids when missing
   - Dedupes by id/src
   - Sorts by priority
   - Sanitizes referrerpolicy
*/
import manifest from "@/data/assets-manifest.json";
import {
  getRegisteredScripts,
  clearScriptRegistry,
  sanitizeReferrerPolicy,
  type ReferrerPolicy,
} from "@/utils/scriptRegistry";
import { getGlobalScripts } from "@/config/globalScripts";

interface Props {
  position: "head" | "footer";
  nonce?: string;
  includeGlobals?: boolean;
  clearAfterPrint?: boolean;
  // Optional tuning (defaults match FilesToLoadJS behavior)
  devSrcBuster?: boolean;       // default: true
  preferMinInProd?: boolean;    // default: true
}

const {
  position,
  nonce,
  includeGlobals = true,
  clearAfterPrint = (position === "footer"),
  devSrcBuster = true,
  preferMinInProd = true,
} = Astro.props as Props;

const isDev = import.meta.env.DEV;
const bust = (import.meta as any)?.hot?.data?.timestamp ?? Date.now();

// ---------- helpers ----------
type Cross = "" | "anonymous" | "use-credentials";
type AnyScript = {
  id?: string;
  name?: string;
  src?: string;
  module?: boolean;
  async?: boolean;
  defer?: boolean;
  nomodule?: boolean;
  integrity?: string;
  crossOrigin?: Cross;
  referrerPolicy?: ReferrerPolicy;
  data?: Record<string, string | number | boolean>;
  code?: string;   // inline payload
  inline?: string; // legacy alias
  priority?: number;
};

function resolveFromManifest(n?: string): string | null {
  if (!n) return null;
  const entry = (manifest as any)?.js?.[n];
  return entry?.file ?? null;
}

function withDevBuster(u: string) {
  if (!isDev || !devSrcBuster) return u;
  return u.includes("?") ? `${u}&t=${bust}` : `${u}?t=${bust}`;
}

function resolveGlobalSrc(name?: string, src?: string): string | null {
  // If a global provides explicit src, honor it (dev adds buster)
  if (src) return isDev ? withDevBuster(src) : src;

  if (!name) return null;

  if (isDev) {
    // Prefer non-minified if manifest happens to exist
    const mf = resolveFromManifest(name);
    if (mf && !mf.endsWith(".min.js")) return withDevBuster(mf);
    // Conventional dev path
    return withDevBuster(`/scripts/${name}.js`);
  }

  // Production
  const mf = resolveFromManifest(name);
  if (mf) return mf;

  if (preferMinInProd) return `/scripts/${name}.min.js`;

  // Last resort
  return `/scripts/${name}.js`;
}

function basenameNoExt(u: string): string {
  const clean = u.split("#")[0].split("?")[0];
  const last = clean.split("/").pop() || clean;
  return last.replace(/\.(m?js)$/, "");
}

function pickId(s: AnyScript, resolvedSrc?: string): string | undefined {
  return s.id || s.name || (resolvedSrc ? basenameNoExt(resolvedSrc) : undefined);
}

function dataSpread(d?: Record<string, string | number | boolean>) {
  if (!d) return {};
  return Object.fromEntries(Object.entries(d).map(([k, v]) => [`data-${k}`, String(v)]));
}

// ---------- read & merge ----------
const registered: AnyScript[] = (getRegisteredScripts(position) || []) as AnyScript[];
const globalsRaw: AnyScript[] = includeGlobals ? (getGlobalScripts(position) || []) : [];

// Resolve globals to final src using manifest/dev logic
const globalsResolved: AnyScript[] = globalsRaw.map((g) => {
  const finalSrc = resolveGlobalSrc(g.name, g.src || undefined);
  const id = pickId(g, finalSrc || undefined);
  return { ...g, id, src: finalSrc || undefined };
});

// merged: globals first (priority still controls final order)
let list: AnyScript[] = [...globalsResolved, ...registered];

// normalize computed flags for template
const normalized = list.map((s) => {
  const inlinePayload = s.code ?? s.inline ?? "";
  const isModule = s.module !== false && !s.nomodule;    // default module=true unless nomodule
  const shouldDefer = !s.async && s.defer !== false;     // default defer=true unless async or explicitly false
  const refp = sanitizeReferrerPolicy(s.referrerPolicy);

  return {
    ...s,
    id: s.id ?? pickId(s, s.src),
    __inline: inlinePayload,
    __hasInline: Boolean(inlinePayload) && !s.src,
    __isModule: isModule,
    __shouldDefer: shouldDefer,
    __referrer: refp,
  };
});

// dedupe by (id || src)
const seen = new Set<string>();
const deduped = normalized.filter((s) => {
  const key =
    (s.id && `id:${s.id}`) ||
    (s.src && `src:${s.src}`) ||
    `inline:${(s.__inline as string).slice(0, 24)}`;
  if (seen.has(key)) return false;
  seen.add(key);
  return true;
});

// sort by priority asc, then stable name/id/src
const sorted = deduped.sort((a, b) => {
  const pa = a.priority ?? 0;
  const pb = b.priority ?? 0;
  if (pa !== pb) return pa - pb;
  const na = (a.name || a.id || a.src || "").toString();
  const nb = (b.name || b.id || b.src || "").toString();
  return na.localeCompare(nb);
});
---

{sorted.map((s) =>
  s.__hasInline ? (
    <script
      id={s.id}
      type={s.__isModule ? "module" : undefined}
      nomodule={s.nomodule ? true : undefined}
      nonce={nonce}
      integrity={s.integrity}
      crossorigin={s.crossOrigin} 
      referrerpolicy={s.__referrer} 
      {...dataSpread(s.data)}
    >
      {s.__inline}
    </script>
  ) : (
    <script
      id={s.id}
      src={s.src}
      type={s.__isModule ? "module" : undefined}
      async={s.async ? true : undefined}
      defer={s.async ? undefined : (s.__shouldDefer ? true : undefined)}
      nomodule={s.nomodule ? true : undefined}
      nonce={nonce}
      integrity={s.integrity}
      crossorigin={s.crossOrigin}
      referrerpolicy={s.__referrer}
      {...dataSpread(s.data)}
    />
  )
)}

{clearAfterPrint && clearScriptRegistry()}
