---
import manifest from "@/data/assets-manifest.json";
import {
  getRegisteredScripts,
  clearScriptRegistry,
  sanitizeReferrerPolicy,
  type ReferrerPolicy,
} from "@/utils/scriptRegistry";
import { getGlobalScripts } from "@/config/globalScripts";

interface Props {
  position: "head" | "footer";
  nonce?: string;
  includeGlobals?: boolean;
  clearAfterPrint?: boolean;
  devSrcBuster?: boolean;    // default: true
  preferMinInProd?: boolean; // default: true
}

const {
  position,
  nonce,
  includeGlobals = true,
  clearAfterPrint = (position === "footer"),
  devSrcBuster = true,
  preferMinInProd = true,
} = Astro.props as Props;

const isDev = import.meta.env.DEV;
const bust = (import.meta as any)?.hot?.data?.timestamp ?? Date.now();

type Cross = "" | "anonymous" | "use-credentials";
type AnyScript = {
  id?: string;
  name?: string;
  src?: string;
  module?: boolean;
  async?: boolean;
  defer?: boolean;
  nomodule?: boolean;
  integrity?: string;
  crossOrigin?: Cross;
  referrerPolicy?: ReferrerPolicy;
  data?: Record<string, string | number | boolean>;
  code?: string;
  inline?: string;
  priority?: number;

  // OPTIONAL convention:
  // manual === true means "don't auto-load this with <script src>, leave it for my loader"
  manual?: boolean;
};

function resolveFromManifest(n?: string): string | null {
  if (!n) return null;
  const entry = (manifest as any)?.js?.[n];
  return entry?.file ?? null;
}

function withDevBuster(u: string) {
  if (!isDev || !devSrcBuster) return u;
  return u.includes("?") ? `${u}&t=${bust}` : `${u}?t=${bust}`;
}

function resolveGlobalSrc(name?: string, src?: string): string | null {
  if (src) return isDev ? withDevBuster(src) : src;
  if (!name) return null;

  if (isDev) {
    const mf = resolveFromManifest(name);
    if (mf && !mf.endsWith(".min.js")) return withDevBuster(mf);
    return withDevBuster(`/scripts/${name}.js`);
  }

  const mf = resolveFromManifest(name);
  if (mf) return mf;

  if (preferMinInProd) return `/scripts/${name}.min.js`;
  return `/scripts/${name}.js`;
}

function basenameNoExt(u: string): string {
  const clean = u.split("#")[0].split("?")[0];
  const last = clean.split("/").pop() || clean;
  return last.replace(/\.(m?js)$/, "");
}

function pickId(s: AnyScript, resolvedSrc?: string): string | undefined {
  return (
    s.id ||
    s.name ||
    (resolvedSrc ? basenameNoExt(resolvedSrc) : undefined)
  );
}

function dataSpread(d?: Record<string, string | number | boolean>) {
  if (!d) return {};
  return Object.fromEntries(
    Object.entries(d).map(([k, v]) => [`data-${k}`, String(v)])
  );
}

/* NEW:
   decide whether this script should be manual-loaded (data-src only)
   Rules you control:
   - explicit s.manual === true
   - OR data.lazy === "true"/"1"
*/
function shouldManualLoad(s: AnyScript): boolean {
  if (s.manual === true) return true;
  const lazyFlag = s.data?.lazy;
  if (lazyFlag === "true" || lazyFlag === "1") return true;
  return false;
}

// ---------- read & merge ----------
const registered: AnyScript[] = (getRegisteredScripts(position) || []) as AnyScript[];
const globalsRaw: AnyScript[] = includeGlobals ? (getGlobalScripts(position) || []) : [];

// Resolve globals -> final src (hashed/minified/etc)
const globalsResolved: AnyScript[] = globalsRaw.map((g) => {
  const finalSrc = resolveGlobalSrc(g.name, g.src || undefined);
  const id = pickId(g, finalSrc || undefined);
  return { ...g, id, src: finalSrc || undefined };
});

// globals first, then registered
let list: AnyScript[] = [...globalsResolved, ...registered];

// normalize
const normalized = list.map((s) => {
  const inlinePayload = s.code ?? s.inline ?? "";
  const isModule = s.module !== false && !s.nomodule; // default = module unless nomodule
  const shouldDefer = !s.async && s.defer !== false;  // default = defer unless async or explicitly false
  const refp = sanitizeReferrerPolicy(s.referrerPolicy);

  // decide src vs data-src
  const manual = shouldManualLoad(s);
  const attrName = manual ? "data-src" : "src";
  const attrValue = s.src; // resolved earlier

  return {
    ...s,
    id: s.id ?? pickId(s, s.src),
    __inline: inlinePayload,
    __hasInline: Boolean(inlinePayload) && !s.src, // inline-only means no external src
    __isModule: isModule,
    __shouldDefer: shouldDefer,
    __referrer: refp,
    __manual: manual,
    __srcAttrName: attrName as "src" | "data-src",
    __srcAttrValue: attrValue,
  };
});

// dedupe by (id || src || inline)
const seen = new Set<string>();
const deduped = normalized.filter((s) => {
  const key =
    (s.id && `id:${s.id}`) ||
    (s.src && `src:${s.src}`) ||
    `inline:${(s.__inline as string).slice(0, 24)}`;
  if (seen.has(key)) return false;
  seen.add(key);
  return true;
});

// sort stable by priority then id/name
const sorted = deduped.sort((a, b) => {
  const pa = a.priority ?? 0;
  const pb = b.priority ?? 0;
  if (pa !== pb) return pa - pb;
  const na = (a.name || a.id || a.src || "").toString();
  const nb = (b.name || b.id || b.src || "").toString();
  return na.localeCompare(nb);
});
---

{sorted.map((s) =>
  s.__hasInline ? (
    <script
      id={s.id}
      type={s.__isModule ? "module" : undefined}
      nomodule={s.nomodule ? true : undefined}
      nonce={nonce}
      integrity={s.integrity}
      crossorigin={s.crossOrigin}
      referrerpolicy={s.__referrer}
      {...dataSpread(s.data)}
    >
      {s.__inline}
    </script>
  ) : (
    <script
      id={s.id}
      {...{
        [s.__srcAttrName]: s.__srcAttrValue,
      }}
      type={s.__isModule ? "module" : undefined}
      async={s.async ? true : undefined}
      defer={s.async ? undefined : (s.__shouldDefer ? true : undefined)}
      nomodule={s.nomodule ? true : undefined}
      nonce={nonce}
      integrity={s.integrity}
      crossorigin={s.crossOrigin}
      referrerpolicy={s.__referrer}
      {...dataSpread(s.data)}
    />
  )
)}

{clearAfterPrint && clearScriptRegistry()}
