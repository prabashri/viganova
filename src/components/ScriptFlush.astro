---
// src/components/ScriptFlush.astro
/* Emits scripts for the given position (head|footer).
   - Merges: (registered scripts) + (global scripts)
   - Auto-ids for globals if missing (from name/src)
   - Dedupes by id or src
   - Sorts by priority
   - Sanitizes referrerpolicy
*/
import {
  getRegisteredScripts,
  clearScriptRegistry,
  sanitizeReferrerPolicy,
  type ReferrerPolicy,
} from "@/utils/scriptRegistry";
import { getGlobalScripts } from "@/config/globalScripts";

interface Props {
  position: "head" | "footer";
  nonce?: string;
  includeGlobals?: boolean;
  clearAfterPrint?: boolean;
}

const {
  position,
  nonce,
  includeGlobals = true,
  clearAfterPrint = (position === "footer"),
} = Astro.props as Props;

// --- helpers -------------------------------------------------
function basenameNoExt(u: string): string {
  const clean = u.split("#")[0].split("?")[0];
  const last = clean.split("/").pop() || clean;
  return last.replace(/\.(m?js)$/, "");
}

function pickId(s: AnyScript): string | undefined {
  return (
    s.id ||
    s.name ||
    (s.src ? basenameNoExt(s.src) : undefined)
  );
}

function dataSpread(d?: Record<string, string | number | boolean>) {
  if (!d) return {};
  return Object.fromEntries(Object.entries(d).map(([k, v]) => [`data-${k}`, String(v)]));
}

// --- read & merge -------------------------------------------
type AnyScript = {
  id?: string;
  name?: string;
  src?: string;
  module?: boolean;
  async?: boolean;
  defer?: boolean;
  nomodule?: boolean;
  integrity?: string;
  crossOrigin?: "" | "anonymous" | "use-credentials";
  referrerPolicy?: ReferrerPolicy;
  data?: Record<string, string | number | boolean>;
  code?: string;
  inline?: string;
  priority?: number;
};

// pull from registry
const registered: AnyScript[] = (getRegisteredScripts(position) || []) as AnyScript[];

// globals (DO NOT register; just merge)
const globals: AnyScript[] = includeGlobals ? (getGlobalScripts(position) || []) : [];

// merged list (globals first so their priority can still sort them)
const merged: AnyScript[] = [...globals, ...registered];

// normalize + computed flags
let list = merged.map((s) => {
  const id = pickId(s);
  const inlinePayload = s.code ?? s.inline ?? "";
  const isModule = s.module !== false && !s.nomodule;     // default to module
  const shouldDefer = !s.async && s.defer !== false;      // default to defer unless async or explicitly false
  const refp = sanitizeReferrerPolicy(s.referrerPolicy);

  return {
    ...s,
    id,
    __inline: inlinePayload,
    __hasInline: Boolean(inlinePayload) && !s.src,
    __isModule: isModule,
    __shouldDefer: shouldDefer,
    __referrer: refp,
  };
});

// dedupe by (id || src)
const seen = new Set<string>();
list = list.filter((s) => {
  const key = s.id ? `id:${s.id}` : (s.src ? `src:${s.src}` : `inline:${(s.__inline as string).slice(0,24)}`);
  if (seen.has(key)) return false;
  seen.add(key);
  return true;
});

// sort deterministically (priority asc, then name/id/src)
list = list.sort((a, b) => {
  const pa = a.priority ?? 0;
  const pb = b.priority ?? 0;
  if (pa !== pb) return pa - pb;
  const na = (a.name || a.id || a.src || "").toString();
  const nb = (b.name || b.id || b.src || "").toString();
  return na.localeCompare(nb);
});
---

{list.map((s) =>
  s.__hasInline ? (
    <script
      id={s.id}
      type={s.__isModule ? "module" : undefined}
      nomodule={s.nomodule ? true : undefined}
      nonce={nonce}
      integrity={s.integrity}
      crossorigin={s.crossOrigin}
      referrerpolicy={s.__referrer}
      {...dataSpread(s.data)}
    >
      {s.__inline}
    </script>
  ) : (
    <script
      id={s.id}
      src={s.src}
      type={s.__isModule ? "module" : undefined}
      async={s.async ? true : undefined}
      defer={s.async ? undefined : (s.__shouldDefer ? true : undefined)}
      nomodule={s.nomodule ? true : undefined}
      nonce={nonce}
      integrity={s.integrity}
      crossorigin={s.crossOrigin}
      referrerpolicy={s.__referrer}
      {...dataSpread(s.data)}
    />
  )
)}

{clearAfterPrint && clearScriptRegistry()}
